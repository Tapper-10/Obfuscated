local Tapper = loadstring(game:HttpGet('https://raw.githubusercontent.com/Tapper-10/Obfuscated/refs/heads/main/Ui.Lua'))()


loadstring(game:HttpGet('https://raw.githubusercontent.com/Tapper-10/Obfuscated/refs/heads/main/Ui.Lua'))()

local Window = Tapper:CreateWindow({
	Name = "PetsGo | Exploit",
	LoadingTitle = "Exploits Loading",
	LoadingSubtitle = "By Tapper10",
	ConfigurationSaving = {
		Enabled = false,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "Example Hub"
	},
	Discord = {
		Enabled = false,
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},
	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Key | Youtube Hub",
		Subtitle = "Key System",
		Note = "Key In Discord Server",
		FileName = "YoutubeHubKey1", -- It is recommended to use something unique as other scripts using Tapper may overwrite your key file
		SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Tapper to get the key from
		Key = {"https://pastebin.com/raw/AtgzSPWK"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})



Tapper:Notify({
	Title = "You executed the script",
	Content = "Very cool gui",
	Duration = 5,
	Image = 13047715178,
	Actions = { -- Notification Buttons
		Ignore = {
			Name = "Okay!",
			Callback = function()
				print("The user tapped Okay!")
			end
		},
	},
})
--[[
local MainTab = Window:CreateTab("Main", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")

local Slider = MainTab:CreateSlider({
	Name = "WalkSpeed Slider",
	Range = {1, 350},
	Increment = 1,
	Suffix = "Speed",
	CurrentValue = 16,
	Flag = "sliderws", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
	end,
})

local Slider = MainTab:CreateSlider({
	Name = "JumpPower Slider",
	Range = {1, 350},
	Increment = 1,
	Suffix = "Speed",
	CurrentValue = 16,
	Flag = "sliderjp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
	end,
})

local Dropdown = MainTab:CreateDropdown({
	Name = "Select Area",
	Options = {"Starter World","Pirate Island","Pineapple Paradise"},
	CurrentOption = {"Starter World"},
	MultipleOptions = false,
	Flag = "dropdownarea", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Option)
		print(Option)
	end,
})

local Input = MainTab:CreateInput({
	Name = "Walkspeed",
	PlaceholderText = "1-500",
	RemoveTextAfterFocusLost = true,
	Callback = function(Text)
		game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Text)
	end,
})

local OtherSection = MainTab:CreateSection("Other")
]]
local RollTab = Window:CreateTab("Auto Roll", nil) -- Title, Image


local runningAutoRoll = true -- Variable to control the loop state

-- Function to start the rolling coroutine
local function startAutoRoll()
	coroutine.wrap(function()
		while runningAutoRoll do
			task.wait(0.1) -- Delay to prevent spamming the server
			local a = game.ReplicatedStorage.Network.Eggs_Roll:InvokeServer(true)
			print(a)
		end
	end)()
end

-- Toggle setup
local Toggle = RollTab:CreateToggle({
	Name = "Auto Roll Pets",
	CurrentValue = true,
	Flag = "ToggleAutoRoll",
	Callback = function(Value)
		runningAutoRoll = Value -- Update the running state based on the toggle value

		if runningAutoRoll then
			startAutoRoll()
		end
	end,
})

-- Start auto-roll on script initialization if enabled
if runningAutoRoll then
	startAutoRoll()
end


local runningAutoRollBonus = false -- Variable to control the loop state

local Toggle = RollTab:CreateToggle({
	Name = "Auto Roll Bonus",
	CurrentValue = false,
	Flag = "ToggleAutoRollBonus", -- Updated flag to avoid overlaps with other toggles
	Callback = function(Value)
		runningAutoRollBonus = Value -- Update the running state based on the toggle value

		if runningAutoRollBonus then
			coroutine.wrap(function()
				while runningAutoRollBonus do
					task.wait(400) -- Delay to prevent spamming the server
					local player = game.Players.LocalPlayer
					local character = player.Character
					local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

					if humanoidRootPart then
						humanoidRootPart.CFrame = CFrame.new(-59, 1.5, -86) -- Teleport player
						task.wait(0.5) -- Small delay to ensure smooth operation
						game:GetService("ReplicatedStorage").Network:FindFirstChild("Retention Dice: Claim"):FireServer()
						local direction = game.Players.LocalPlayer.PlayerGui.BonusRoll.Frame

						-- Script generated by SimpleSpy - credits to exx#9394
						game.ReplicatedStorage.Network["Bonus Rolls: Reject"]:InvokeServer(true)
						--	if direction.Visible == true then
						--		direction.Visible = false
						--	end
					end
				end
			end)()
		end
	end,
})


local AutoFarm = Window:CreateTab("Auto Farm", nil) -- Title, Image

-- Auto Break Toggle
-- Global flags to auto-start the functionalities
getgenv().autoBreak = true -- Set to true to auto-start Auto Break
getgenv().collect = true -- Set to true to auto-start Auto Collect

-- Auto Break Functionality
local function startAutoBreak()
	coroutine.wrap(function()
		while getgenv().autoBreak do
			task.wait(0.35) -- Delay to prevent overloading the game

			-- Loop through all breakable object models
			for _, model in pairs(game:GetService("Workspace")["__THINGS"].Breakables:GetChildren()) do
				if model:IsA("Model") then
					local modelName = model.Name

					-- Case 1: Breakable objects with pet IDs
					for _, pet in pairs(game:GetService("Workspace")["__THINGS"].Pets:GetChildren()) do
						local petID = pet.Name
						local petIDNumber = tonumber(petID)

						if petIDNumber then
							local args = {
								[1] = {
									[petID] = tonumber(modelName) -- Convert model name to number
								}
							}

							-- Fire server event to join pet with breakable
							game:GetService("ReplicatedStorage").Network.Breakables_JoinPetBulk:FireServer(unpack(args))
							
							task.wait(0.05) -- Small delay
						end
					end

					-- Case 2: Target breakable objects with 'v' and 't'
					local args = {
						[1] = {
							["1712"] = {
								["v"] = modelName,  -- Use the 'v' value from the model
								["t"] = 2           -- Use the 't' value
							}
						}
					}

					-- Fire server event for setting targets
					game:GetService("ReplicatedStorage").Network.Pets_SetTargetBulk:FireServer(unpack(args))
					task.wait(0.05) -- Small delay
				end
			end
		end
	end)()
end

-- Auto Collect Functionality
local function startAutoCollect()
	coroutine.wrap(function()
		while getgenv().collect do
			task.wait(240) -- Interval for collecting orbs (adjustable)

			local player = game.Players.LocalPlayer
			local character = player.Character
			local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

			if humanoidRootPart then
				-- Loop through all orbs
				for _, Orb in pairs(game:GetService("Workspace")["__THINGS"].Orbs:GetChildren()) do
					if Orb:IsA("BasePart") then -- Ensure it's a valid object
						humanoidRootPart.CFrame = Orb.CFrame -- Move player to the orb
						task.wait(0.2) -- Small delay between teleports
					end
				end
			end
		end
	end)()
end

-- Start Auto Break and Auto Collect if enabled
if getgenv().autoBreak then startAutoBreak() end
if getgenv().collect then startAutoCollect() end

-- Auto Break Toggle
local AutoBreak = AutoFarm:CreateToggle({
	Name = "Auto Break",
	CurrentValue = getgenv().autoBreak,
	Flag = "ToggleAutoBreak",
	Callback = function(Value)
		getgenv().autoBreak = Value
		if Value then
			startAutoBreak()
		end
	end,
})

-- Auto Collect Toggle
local AutoCollect = AutoFarm:CreateToggle({
	Name = "Auto Collect",
	CurrentValue = getgenv().collect,
	Flag = "ToggleAutoCollect",
	Callback = function(Value)
		getgenv().collect = Value
		if Value then
			startAutoCollect()
		end
	end,
})



local FishingSection = AutoFarm:CreateSection("Fishing")
local running = true -- Variable to control the loop state

local function startAutoFishing()
	coroutine.wrap(function()
		while running do
			task.wait(10) -- Delay to prevent spamming the server

			local player = game.Players.LocalPlayer
			local character = player.Character
			local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

			if humanoidRootPart then
				local targetPosition = Vector3.new(-206, 2.5, 208)
				local distance = (humanoidRootPart.Position - targetPosition).Magnitude

				if distance > 5 then
					humanoidRootPart.CFrame = CFrame.new(targetPosition)
				end
			end
		end
	end)()
end

local FishingToggle = AutoFarm:CreateToggle({
	Name = "Auto Fishing",
	CurrentValue = true,
	Flag = "ToggleFishing",
	Callback = function(Value)
		running = Value -- Update the running state based on the toggle value
		if running then
			startAutoFishing()
		end
	end,
})

if running then
	startAutoFishing()
end



local AutoMerchant = Window:CreateTab("Auto Buy", nil) -- Title, Image

local runningAutoBuyMerchant = true -- Variable to control the loop state

-- Function to start the Auto Buy Merchant process
local function startAutoBuyMerchant()
	coroutine.wrap(function()
		while runningAutoBuyMerchant do
			task.wait(1) -- Delay to prevent spamming the server
			local direction = game.ReplicatedStorage.Network.CustomMerchants_Purchase
			for i = 1, 6 do
				direction:InvokeServer("StandardMerchant", i, true)
				task.wait(0.1)
			end
		end
	end)()
end

-- Toggle for Auto Buy Merchant
local AutoBuyMerchant = AutoMerchant:CreateToggle({
	Name = "Auto Buy Merchant",
	CurrentValue = true,
	Flag = "ToggleAutoMerchantBuy",
	Callback = function(Value)
		runningAutoBuyMerchant = Value -- Update the running state
		if runningAutoBuyMerchant then
			startAutoBuyMerchant()
		end
	end,
})

-- Start Auto Buy Merchant on script initialization if enabled
if runningAutoBuyMerchant then
	startAutoBuyMerchant()
end


-- Auto Buy Fishing Toggle
local runningAutoBuyFishing = true -- Variable to control the loop state

-- Function to start the Auto Buy Fishing process
local function startAutoBuyFishing()
	coroutine.wrap(function()
		while runningAutoBuyFishing do
			task.wait(1) -- Delay to prevent spamming the server
			local direction = game.ReplicatedStorage.Network.CustomMerchants_Purchase
			for i = 1, 6 do
				direction:InvokeServer("FishingMerchant", i, true)
				task.wait(0.1)
			end
		end
	end)()
end

-- Toggle for Auto Buy Fishing
local AutoBuyFishing = AutoMerchant:CreateToggle({
	Name = "Auto Buy Fishing",
	CurrentValue = true,
	Flag = "ToggleAutoFishingBuy",
	Callback = function(Value)
		runningAutoBuyFishing = Value -- Update the running state
		if runningAutoBuyFishing then
			startAutoBuyFishing()
		end
	end,
})

-- Start Auto Buy Fishing on script initialization if enabled
if runningAutoBuyFishing then
	startAutoBuyFishing()
end



-- Auto Buy Jelly Toggle
local runningAutoBuyJelly = true -- Variable to control the loop state

-- Function to start the Auto Buy Jelly process
local function startAutoBuyJelly()
	coroutine.wrap(function()
		while runningAutoBuyJelly do
			task.wait(1) -- Delay to prevent spamming the server
			local direction = game.ReplicatedStorage.Network.CustomMerchants_Purchase
			for i = 1, 6 do
				direction:InvokeServer("JellyMerchant", i, true)
				task.wait(0.1)
			end
		end
	end)()
end

-- Toggle for Auto Buy Jelly
local AutoBuyJelly = AutoMerchant:CreateToggle({
	Name = "Auto Buy Jelly",
	CurrentValue = true,
	Flag = "ToggleAutoJellyBuy",
	Callback = function(Value)
		runningAutoBuyJelly = Value -- Update the running state
		if runningAutoBuyJelly then
			startAutoBuyJelly()
		end
	end,
})

-- Start Auto Buy Jelly on script initialization if enabled
if runningAutoBuyJelly then
	startAutoBuyJelly()
end

--Auto Buy vending

local runningAutoBuyVending = true -- Variable to control the loop state

-- Function to start the Auto Buy Vending process
local function startAutoBuyVending()
	coroutine.wrap(function()
		while runningAutoBuyVending do
			task.wait(1) -- Delay to prevent spamming the server
			local direction = game.ReplicatedStorage.Network.VendingMachines_Purchase
			direction:InvokeServer("PotionVendingMachine", true)
			task.wait(0.1)
		end
	end)()
end

-- Toggle for Auto Buy Vending
local AutoBuyVending = AutoMerchant:CreateToggle({
	Name = "Auto Buy Vending",
	CurrentValue = true,
	Flag = "ToggleAutoVendingBuy",
	Callback = function(Value)
		runningAutoBuyVending = Value -- Update the running state
		if runningAutoBuyVending then
			startAutoBuyVending()
		end
	end,
})

-- Start Auto Buy Vending on script initialization if enabled
if runningAutoBuyVending then
	startAutoBuyVending()
end

--Auto Use

local AutoUseTab = Window:CreateTab("Auto Use", nil)
local AutoUseFruitSection = AutoUseTab:CreateSection("Auto Use Fruit")

local FruitAmount = 1
local KeepFruit = 0
local SelectedFruits = {"Apple", "Shiny Apple", "Orange", "Shiny Orange", "Pineapple", "Shiny Pineapple", "Rainbow", "Watermelon", "Shiny Watermelon"} -- Table to store selected fruits (normal and shiny)

-- Multi-select Dropdown for selecting which fruits to consume
local Dropdown = AutoUseTab:CreateDropdown({
	Name = "Select Fruits",
	Options = {
		"Apple", "Shiny Apple",
		"Banana", "Shiny Banana",
		"Orange", "Shiny Orange",
		"Pineapple", "Shiny Pineapple",
		"Rainbow", "Shiny Rainbow",
		"Watermelon", "Shiny Watermelon"
	}, -- Include shiny variants
	CurrentOption = {}, -- Default empty selection
	MultipleOptions = true, -- Allow selecting multiple fruits
	Flag = "dropdownfruits", -- Unique identifier
	Callback = function(Options)
		SelectedFruits = Options -- Update the selected fruits
	end,
})

-- Function to consume the selected fruits (normal and shiny)
local function consumeSelectedFruits(fruitTable)
	for key, fruit in pairs(fruitTable) do
		if fruit and type(fruit) == "table" and fruit.id and fruit._am then
			local fruitType = fruit.sh and ("Shiny " .. fruit.id) or fruit.id -- Determine if the fruit is shiny

			if table.find(SelectedFruits, fruitType) then -- Match with selected fruits
				if fruit._am > KeepFruit then
					local consumeFruit = game:GetService("ReplicatedStorage").Network["Fruits: Consume"]
					consumeFruit:InvokeServer(key, FruitAmount, false)
				end
			end
		end
	end
end

-- Toggle for Auto Eating the Selected Fruits
local runningAutoEatFruits = true
local Toggle = AutoUseTab:CreateToggle({
	Name = "Auto Eat Selected Fruits",
	CurrentValue = true,
	Flag = "ToggleAutoEatSelectedFruits", -- Unique identifier
	Callback = function(Value)
		runningAutoEatFruits = Value -- Update the loop state

		if runningAutoEatFruits then
			while runningAutoEatFruits do
				local Library = game.ReplicatedStorage:WaitForChild("Library")
				local Client = Library:FindFirstChild("Client")
				local Network = require(Client:WaitForChild("Network"))
				local Save = require(Client:FindFirstChild("Save")).Get()

				-- Ensure only the Inventory table inside Save is used
				if Save.Inventory and Save.Inventory.Fruit then
					consumeSelectedFruits(Save.Inventory.Fruit)
				else
					print("No fruits found in inventory.")
				end
				wait(math.random(5,15)) -- Prevent infinite loop from freezing the game
			end
		end
	end,
})

-- Space Section for Inputs
local InputSection = AutoUseTab:CreateSection("Inputs")

-- Fruit Amount Input (1, 5, 10, 30)
local AmountUseInput = AutoUseTab:CreateInput({
	Name = "Fruit Auto Use Amount",
	PlaceholderText = "1,5,10,30",
	RemoveTextAfterFocusLost = false,
	ClearTextOnFocus = true,
	Callback = function(Text)
		local numberText = tonumber(Text)
		if numberText == 1 or numberText == 5 or numberText == 10 or numberText == 30 then
			FruitAmount = numberText
		else
			print("Invalid input. Please enter 1, 5, 10, or 30.") -- Notify the user of invalid input
		end
	end,
})

-- Fruit Keep Min Amount (to ensure fruits aren't consumed if below the threshold)
local KeepFruitInput = AutoUseTab:CreateInput({
	Name = "Fruit Keep Min Amount",
	PlaceholderText = "0-inf",
	RemoveTextAfterFocusLost = false,
	ClearTextOnFocus = true,
	Callback = function(Text)
		local numberText = tonumber(Text)
		if numberText then
			KeepFruit = numberText
		else
			print("Invalid input. Please enter a valid number.")
		end
	end,
})



--[[
local Test2 = AutoUseTab:CreateButton({
	Name = "Printer",
	Callback = function()
		print(FruitAmount)
	end
})
]]
--Space

-- Configuration for bait types
local AutoBaitSection = AutoUseTab:CreateSection("Auto Use Baits")

-- Configuration for bait types
local BaitAmount = 1 -- Amount of bait to consume per use
local SelectedBaits = {"BasicBait", "RareBait", "EpicBait"} -- Table to store selected bait types
local Baits = {
	BasicBait = 1,
	RareBait = 2,
	EpicBait = 3,
	LegendaryBait = 4,
	ExclusiveBait = 5
}

-- Dropdown for selecting bait types
local BaitDropdown = AutoUseTab:CreateDropdown({
	Name = "Select Bait Types",
	Options = { "BasicBait", "RareBait", "EpicBait", "LegendaryBait", "ExclusiveBait" },
	CurrentOption = {"BasicBait", "RareBait", "EpicBait"}, -- Default empty selection
	MultipleOptions = true, -- Allow multiple selections
	Flag = "dropdownbaits", -- Unique identifier
	Callback = function(Options)
		SelectedBaits = Options -- Update the selected bait types
		-- Uncomment to debug:
		-- print("Selected bait types: " .. table.concat(Options, ", "))
	end,
})

-- Function to consume the selected bait types
local function consumeSelectedBaits(consumableTable)
	for key, consumable in pairs(consumableTable) do
		-- Validate consumable entries
		if consumable and type(consumable) == "table" and consumable.id == "Fishing Bait" and consumable.tn and consumable._am then
			-- Resolve bait type based on `tn` value
			local baitType = nil
			for name, tnValue in pairs(Baits) do
				if consumable.tn == tnValue then
					baitType = name
					break
				end
			end

			-- Check if the resolved bait type is selected and has enough amount
			if baitType and table.find(SelectedBaits, baitType) and consumable._am > 0 then
				-- Consume the bait
				local consumeBait = game:GetService("ReplicatedStorage").Network["Consumables_Consume"]
				consumeBait:InvokeServer(key, BaitAmount, false)
			end
		end
	end
end

-- Toggle for Auto Using the Selected Baits
local runningAutoBait = true

-- Function to start the auto-bait loop
local function startAutoBait()
	coroutine.wrap(function()
		while runningAutoBait do
			local Library = game.ReplicatedStorage:WaitForChild("Library")
			local Client = Library:FindFirstChild("Client")
			local Save = require(Client:FindFirstChild("Save")).Get()

			-- Check for consumables in the inventory
			if Save.Inventory and Save.Inventory.Consumable then
				consumeSelectedBaits(Save.Inventory.Consumable)
			else
				print("No consumables found in inventory.")
			end

			wait(1) -- Prevent infinite loop from freezing the game
		end
	end)()
end

-- Toggle for enabling/disabling Auto Bait consumption
local BaitToggle = AutoUseTab:CreateToggle({
	Name = "Auto Use Selected Bait Types",
	CurrentValue = true,
	Flag = "ToggleAutoUseSelectedBaits",
	Callback = function(Value)
		runningAutoBait = Value -- Update loop state
		if runningAutoBait then
			startAutoBait()
		end
	end,
})



--Space
local InputSection2 = AutoUseTab:CreateSection("Inputs")
local AmountUseInput = AutoUseTab:CreateInput({
	Name = "Bait Auto Use Amount",
	PlaceholderText = "1,5,10,25,50",
	RemoveTextAfterFocusLost = false,
	ClearTextOnFocus = true,
	Callback = function(Text)

		local numberText = tonumber(Text)

		if numberText == 1 or numberText == 5 or numberText == 10 or numberText == 25 or numberText == 50 then
			BaitAmount = numberText
			--			print("Fruit Amount set to: " .. FruitAmount) -- Optional: Debugging line
		else
			print("Invalid input. Please enter 1,5,10,25 or 50.") -- Notify the user of invalid input
		end
	end,
})

--Space
local LootboxSection = AutoUseTab:CreateSection("Auto Use Lootbox")

-- Configuration for lootbox types
local LootboxAmount = 1 -- Amount of lootboxes to consume per use
local SelectedLootboxes = {} -- Table to store selected lootbox types
local Lootboxes = {
	"Basic Treasure Chest",
	"Rare Treasure Chest",
	"Epic Treasure Chest",
	"Legendary Treasure Chest",
	"Exclusive Treasure Chest"
}

-- Dropdown for selecting lootbox types
local LootboxDropdown = AutoUseTab:CreateDropdown({
	Name = "Select Lootbox Types",
	Options = Lootboxes, -- Provide lootbox options
	CurrentOption = {	"Basic Treasure Chest","Rare Treasure Chest","Epic Treasure Chest",}, -- Default empty selection
	MultipleOptions = true, -- Allow multiple selections
	Flag = "dropdownlootboxes", -- Unique identifier
	Callback = function(Options)
		SelectedLootboxes = Options -- Update the selected lootbox types
		-- Uncomment to debug:
		-- print("Selected lootbox types: " .. table.concat(Options, ", "))
	end,
})

-- Function to consume the selected lootboxes
local function consumeSelectedLootboxes(consumableTable)
	for key, consumable in pairs(consumableTable) do
		-- Validate consumable entries
		if consumable and type(consumable) == "table" and consumable.id and consumable._am then
			-- Check if the consumable id matches any of the selected lootboxes
			if table.find(SelectedLootboxes, consumable.id) then
				if consumable._am > 0 then
					-- Attempt to consume the lootbox
					local args = {
						[1] = key, -- Key of the lootbox in the consumableTable
						[2] = LootboxAmount, -- Amount to consume
					}

					local success, result = pcall(function()
						return game:GetService("ReplicatedStorage").Network:FindFirstChild("Lootbox: Open"):InvokeServer(unpack(args))
					end)

					-- Handle success or error
					if success then
						print("Lootbox successfully consumed:", consumable.id)
					else
						warn("Error consuming lootbox:", result)
					end
				end
			end
		end
	end
end

-- Toggle for Auto Using the Selected Lootboxes
local runningAutoLootbox = true

-- Function to start the auto-lootbox loop
local function startAutoLootbox()
	coroutine.wrap(function()
		while runningAutoLootbox do
			local Library = game.ReplicatedStorage:WaitForChild("Library")
			local Client = Library:FindFirstChild("Client")
			local Network = require(Client:WaitForChild("Network"))
			local Save = require(Client:FindFirstChild("Save")).Get()

			-- Check for lootboxes in the inventory
			if Save.Inventory and Save.Inventory.Lootbox then
				consumeSelectedLootboxes(Save.Inventory.Lootbox)
			else
				print("No lootboxes found in inventory.")
			end

			wait(1) -- Prevent infinite loop from freezing the game
		end
	end)()
end

-- Toggle for enabling/disabling Auto Lootbox consumption
local LootboxToggle = AutoUseTab:CreateToggle({
	Name = "Auto Use Selected Lootbox Types",
	CurrentValue = true,
	Flag = "ToggleAutoUseSelectedLootboxes",
	Callback = function(Value)
		runningAutoLootbox = Value -- Update the loop state
		if runningAutoLootbox then
			startAutoLootbox()
		end
	end,
})


local InputSection3 = AutoUseTab:CreateSection("Inputs")
local AmountUseInput = AutoUseTab:CreateInput({
	Name = "Lootbox Auto Use Amount",
	PlaceholderText = "1,5,10,25,50",
	RemoveTextAfterFocusLost = false,
	ClearTextOnFocus = true,
	Callback = function(Text)

		local numberText = tonumber(Text)

		if numberText == 1 or numberText == 5 or numberText == 10 or numberText == 25 or numberText == 50 then
			LootboxAmount = numberText
			--			print("Fruit Amount set to: " .. FruitAmount) -- Optional: Debugging line
		else
			print("Invalid input. Please enter 1,5,10,25 or 50.") -- Notify the user of invalid input
		end
	end,
})

--Space

local TpTab = Window:CreateTab("Tp", nil) -- Title, Image

local TpBonusRoll = TpTab:CreateButton({
	Name = "Tp Bonus Roll",
	Callback = function()

		local player = game.Players.LocalPlayer
		local character = player.Character
		local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

		if humanoidRootPart then
			humanoidRootPart.CFrame = CFrame.new(-45, 1.5, -86) -- Teleport player
		end
	end,
})

local MailboxTab = Window:CreateTab("MailBox", nil) -- Title, Image
-- Auto Mailbox Item Sending Script
-- Organized Items Table
-- Helper function to extract the keys from a table
-- Function to find and send selected items
local function findAndSendItems(recipient)
	-- Validate recipient
	if not recipient or type(recipient) ~= "string" then
		warn("Invalid recipient.")
		return
	end

	-- Retrieve inventory data
	local Library = game.ReplicatedStorage:WaitForChild("Library")
	local Client = Library:FindFirstChild("Client")
	local Network = Client and require(Client:FindFirstChild("Network"))
	local Save = Client and require(Client:FindFirstChild("Save")).Get()

	if not Library or not Client or not Network or not Save then
		warn("Required dependencies are missing.")
		return
	end

	if not Save.Inventory then
		warn("Inventory data is missing.")
		return
	end

	if not SelectedItems or type(SelectedItems) ~= "table" then
		warn("SelectedItems is not a valid table.")
		return
	end

	-- Iterate over the selected items
	for _, selectedItemName in pairs(SelectedItems) do
		local itemData = Items[selectedItemName]
		if not itemData then
			warn("Selected item data not found:", selectedItemName)
			continue
		end

		local foundKey = nil
		local inventoryFound = false
		local amountToSend = 1

		-- Search for the item in specific inventory categories
		for _, category in pairs({"Consumable", "Lootbox", "Misc", "Pet"}) do
			if Save.Inventory[category] then
				for key, inventoryItem in pairs(Save.Inventory[category]) do
					if inventoryItem.id == itemData.ID and (not itemData.tn or inventoryItem.tn == itemData.tn) then
						-- Unlock item if locked
						if inventoryItem._lk then
							local args = {
								[1] = key,
								[2] = false
							}
							game:GetService("ReplicatedStorage").Network.Locking_SetLocked:InvokeServer(unpack(args))
							print("Unlocked item:", selectedItemName)
						end

						-- Check item amount
						foundKey = key
						if itemData.Type == "Pet" or not inventoryItem._am then
							amountToSend = 1 -- Default to 1 for pets or non-stackable items
						else
							amountToSend = inventoryItem._am
						end

						inventoryFound = true
						print(string.format("Before Send %d of item '%s' (%s) to %s.", amountToSend, selectedItemName, itemData.ID, recipient))
						break
					end
				end
			end
			if inventoryFound then break end
		end

		-- Check if the item is found before attempting to send
		if inventoryFound and foundKey and amountToSend then
			print(string.format("Sending %d of item '%s' (%s) to %s.", amountToSend, selectedItemName, itemData.ID, recipient))
			local args = {
				recipient,
				"Gift",
				itemData.Type,
				foundKey,
				amountToSend
			}
			local success, errorMessage = pcall(function()
				game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send"):InvokeServer(unpack(args))
			end)

			-- Debug message if the send fails
			if not success then
				warn(string.format("Failed to send '%s': %s", selectedItemName, errorMessage))
				print(string.format("Sending Failed %d of item '%s' (%s) to %s.", foundKey, amountToSend, selectedItemName, itemData.ID, recipient))
			end
		else
			-- If item was not found or amount is 0, skip sending
			warn(string.format("Item '%s' not found or insufficient amount to send.", selectedItemName))
			print(string.format("Did not attempt to send %d of item '%s' (%s) to %s.", foundKey or 0, selectedItemName, itemData.ID, recipient))
		end
	end
end


local InputSection4 = MailboxTab:CreateSection("Inputs")
local SendUsernameInput = MailboxTab:CreateInput({
	Name = "Send Pet to",
	PlaceholderText = "Username",
	RemoveTextAfterFocusLost = false,
	ClearTextOnFocus = true,
	Callback = function(Text)

		local recipient = (Text)
	end
})




-- Toggle for sending selected items
local ItemSendToggle = MailboxTab:CreateToggle({
	Name = "Send Selected Items",
	CurrentValue = false,
	Flag = "ToggleMultiItemSend",
	Callback = function(Value)
		runningMailboxSend = Value

		if runningMailboxSend then
			-- Start a coroutine to handle repeated sending
			coroutine.wrap(function()
				while runningMailboxSend do
					findAndSendItems("davidjenej") -- Update recipient as needed
					task.wait(5) -- Prevent server spamming
				end
			end)()
		end
	end
})



--Space


local MiscTab = Window:CreateTab("ðŸŽ² Misc", nil) -- Title, Image

local Button1 = MiscTab:CreateButton({
	Name = "Collect Relics",
	Callback = function()
		local consumeRelic = game:GetService("ReplicatedStorage").Network["Relic_Found"]
		for relicId = 1, 50 do
			consumeRelic:InvokeServer(relicId, true)
		end
	end
})

local Button2 = MiscTab:CreateButton({
	Name = "Simple Spy",
	Callback = function()
		loadstring(game:HttpGet("https://github.com/exxtremestuffs/SimpleSpySource/raw/master/SimpleSpy.lua"))()
	end
})
--
local runningAntiAFK = false
local AntiAFK = MiscTab:CreateToggle({
	Name = "Anti-AFK",
	CurrentValue = false,
	Flag = "ToggleAntiAFK",
	Callback = function(Value)
		runningAntiAFK = Value -- Update the shared variable

		if runningAntiAFK then
			-- Anti-AFK logic in a coroutine
			coroutine.wrap(function()
				-- Simple Anti-AFK Script for Roblox
				-- Place this script in a LocalScript in StarterPlayerScripts

				local VirtualUser = game:GetService("VirtualUser")
				local Players = game:GetService("Players")
				local player = Players.LocalPlayer

				-- Anti-AFK event listener
				player.Idled:Connect(function()
					-- Simulate a jump or small movement
					VirtualUser:CaptureController()
					VirtualUser:ClickButton2(Vector2.new(0, 0))
					print("Anti-AFK triggered!")
				end)

				print("Anti-AFK script loaded successfully.")

			end)()
		end
	end
})
